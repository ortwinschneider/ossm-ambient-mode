= 4. Install the demo application and ingress gateway

This demo application is based on the link:https://kiali.io/docs/tutorials/travels/[Kiali Travel Demo Tutorial] and will deploy several services grouped into three namespaces. 

IMPORTANT: Navigate to the subdirectory: `040-travel-demo-app`

[#create-namespace]
== 4.1 Create the namespaces

Create the namespaces for the Kiali Travel Demo with the following command:

[source,yaml]
----
apiVersion: v1
kind: Namespace
metadata:
  labels:
    istio-discovery: enabled
  name: travel-agency
spec: {}
---
apiVersion: v1
kind: Namespace
metadata:
  labels:
    istio-discovery: enabled
  name: travel-portal
spec: {}
---
apiVersion: v1
kind: Namespace
metadata:
  labels:
    istio-discovery: enabled
  name: travel-control
spec: {}
----

[source,bash,role=execute]
----
oc apply -f 01_1-ns-create.yaml
----

The namespaces are labeled with the configured istio discovery selector.

[#create-pod-monitors]
== 4.2 Create pod monitors

PodMonitor objects must be applied in all mesh namespaces:

[source,bash,role=execute]
----
oc apply -f 01_2-pod-monitors-create.yaml
----

[#deploy-application-components]
== 4.3 Deploy the application components

**Step 1**: Deploy the `travel-agency` components with: 

[source,bash,role=execute]
----
oc apply -n travel-agency -f 02_1-travel-agency-app.yaml
----

[source,bash]
----
secret/mysql-credentials created
service/mysqldb created
deployment.apps/mysqldb-v1 created
deployment.apps/cars-v1 created
service/cars created
deployment.apps/discounts-v1 created
service/discounts created
deployment.apps/flights-v1 created
service/flights created
deployment.apps/hotels-v1 created
service/hotels created
deployment.apps/insurances-v1 created
service/insurances created
deployment.apps/travels-v1 created
service/travels created
----

**Step 2**: Deploy the `travel-portal` components with: 

[source,bash,role=execute]
----
oc apply -n travel-portal -f 02_2-travel-portal-app.yaml
----

[source,bash]
----
deployment.apps/voyages created
service/voyages created
deployment.apps/viaggi created
service/viaggi created
deployment.apps/travels created
service/travels created
----

**Step 3**: Deploy the `travel-control` components with: 

[source,bash,role=execute]
----
oc apply -n travel-control -f 02_3-travel-control-app.yaml
----

[source,bash]
----
deployment.apps/control created
service/control created
----

**Step 4**: Create a Route for the `Travel Control Dashboard` with: 

[source,bash,role=execute]
----
oc apply -f 02_4-travel-control-route.yaml
----

Get the Travel Control Dashboard URL from the Route by running the following command:

[source,bash,role=execute]
----
echo "https://$(oc get routes -n travel-control route-travel-control -o jsonpath='{.spec.host}')"
----

Open the Dashboard and verify everything is working.

IMPORTANT: **Please keep the browser window open so that you continuously send requests to the backend.**

image:travel-control-dashboard.png[travel-control-dashboard.png]

[#add-application-to-ambient-mesh]
== 4.4 Add the application to the Ambient Mesh

[IMPORTANT]
====
Right now, we have deployed the application components in namespaces, that are "visible" to the Istio control plane (due to discoverySelectors), but the application pods are **not enrolled in the data plane**.  

The application is treated as a standard Kubernetes workload. 
Even though Istio "knows" about the service, it knows that the specific pod does not have a proxy (ztunnel or sidecar) attached to it.
====

We can verify this by the following command:

[source,bash,role=execute]
----
istioctl ztunnel-config workload -n ztunnel
----

[source,bash]
----
NAMESPACE      POD NAME                        ADDRESS      NODE     WAYPOINT PROTOCOL
travel-agency  cars-v1-75f98c6f58-6g8nv        10.130.1.114 master-0 None     TCP
travel-agency  discounts-v1-6dccdff9ff-dwflq   10.130.1.116 master-0 None     TCP
travel-agency  flights-v1-6b7b99b764-g44mc     10.130.1.117 master-0 None     TCP
travel-agency  hotels-v1-6bcc9b877d-bhbrq      10.129.1.105 master-1 None     TCP
travel-agency  insurances-v1-75cb48b577-nszkq  10.129.1.106 master-1 None     TCP
travel-agency  mysqldb-v1-6657d57779-frcfj     10.130.1.115 master-0 None     TCP
travel-agency  travels-v1-56895446c5-l6qmm     10.128.0.117 master-2 None     TCP
travel-control control-6474d4c775-qt288        10.129.1.107 master-1 None     TCP
travel-portal  travels-6684f75cd5-lfd9m        10.130.1.119 master-0 None     TCP
travel-portal  viaggi-59988c897c-blffl         10.130.1.118 master-0 None     TCP
travel-portal  voyages-6c86bcdb5d-4zfzd        10.128.0.118 master-2 None     TCP
----

[NOTE]
====
Key columns to watch:

PROTOCOL:

- HBONE: The workload is part of the Ambient Mesh (mTLS enabled).
- TCP: The workload is not in the mesh (not part of the dataplane).

WAYPOINT: 

- Shows if there is a Layer 7 Waypoint proxy enforcing policy for that workload.
====

Now let's add the application to the Ambient Mesh by labeling the namespaces with `istio.io/dataplane-mode=ambient`:

[source,bash,role=execute]
----
oc apply -f 03-ns-add-to-mesh.yaml
----

Verify that the application is now part of the Mesh:

[source,bash,role=execute]
----
istioctl ztunnel-config workload -n ztunnel
----

[source,bash]
----
NAMESPACE      POD NAME                        ADDRESS      NODE     WAYPOINT PROTOCOL
travel-agency  cars-v1-75f98c6f58-6g8nv        10.130.1.114 master-0 None     HBONE
travel-agency  discounts-v1-6dccdff9ff-dwflq   10.130.1.116 master-0 None     HBONE
travel-agency  flights-v1-6b7b99b764-g44mc     10.130.1.117 master-0 None     HBONE
travel-agency  hotels-v1-6bcc9b877d-bhbrq      10.129.1.105 master-1 None     HBONE
travel-agency  insurances-v1-75cb48b577-nszkq  10.129.1.106 master-1 None     HBONE
travel-agency  mysqldb-v1-6657d57779-frcfj     10.130.1.115 master-0 None     HBONE
travel-agency  travels-v1-56895446c5-l6qmm     10.128.0.117 master-2 None     HBONE
travel-control control-6474d4c775-qt288        10.129.1.107 master-1 None     HBONE
travel-portal  travels-6684f75cd5-lfd9m        10.130.1.119 master-0 None     HBONE
travel-portal  viaggi-59988c897c-blffl         10.130.1.118 master-0 None     HBONE
travel-portal  voyages-6c86bcdb5d-4zfzd        10.128.0.118 master-2 None     HBONE
----

HBONE stands for HTTP-Based Overlay Network Environment. 
It is the custom tunneling protocol Istio Ambient Mesh uses to transport traffic securely between nodes (Ztunnels) and Waypoint proxies.

After the label is applied, all L4 traffic to and from the ambient mesh is intercepted and secured via mutual TLS (mTLS) by the ztunnel. 

NOTE: Congratulations! You have successfully added the Travel Demo to ambient mesh. No further configuration is required and also no restart of the workloads.

== When do I need Waypoint Proxies?

You can add a waypoint proxy if workloads require any of the following L7 capabilities:

[NOTE]
====
**Traffic management:**
- Advanced HTTP routing, load balancing, circuit breaking, rate limiting, fault injection, retries, and timeouts

**Security**
- Authorization policies based on L7 attributes such as request type or HTTP headers

**Observability**
- HTTP metrics, access logging, and tracing for application traffic
====

[#create-waypoint]
== 4.5 Create a Waypoint Proxy

Istio is sending traffic from a gateway to the destination directly, even if that specific destination is enrolled in a waypoint.

We can enable ingress waypoint routing on a service, such that traffic will be sent from the gateway to the configured waypoint, not to the destination service. 

So, first create a Waypoint Proxy.

[source,yaml]
----
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: travel-control-waypoint
  namespace: travel-control
  labels:
    istio.io/waypoint-for: service
spec:
  gatewayClassName: istio-waypoint
  listeners:
  - name: mesh
    port: 15008
    protocol: HBONE             
----

[source,bash,role=execute]
----
oc apply -f 04_1-control-waypoint-create.yaml
----

[#label-the-travel-control-namespace]
== 4.6 Label the travel-control namespace to use the waypoint

Now label the namespace to enroll the services in the waypoint.

[source,bash,role=execute]
----
oc apply -f 04_2-label-ns-for-waypoint.yaml
----

[#create-ingress-gateway]
== 4.7 Create an Ingress Gateway

The following configuration is defining a basic `Ingress Gateway` and an `HTTPRoute` using the Kubernetes Gateway API, which Istio fully supports and implements. It's essentially setting up a public entry point for HTTP traffic and routing all incoming requests to the control service.

[source,yaml]
----
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: travel-gateway
  namespace: travel-control
spec:
  gatewayClassName: istio
  listeners:
  - name: default
    port: 80
    protocol: HTTP
    allowedRoutes:
      namespaces:
        from: All
---
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: travel-gateway-default-route
  namespace: travel-control
spec:
  parentRefs:
  - name: travel-gateway
  rules:
  - matches:
    - path:
        type: PathPrefix
        value: /
    backendRefs:
    - name: control
      port: 8080         
----

[source,bash,role=execute]
----
oc apply -f 04_3-ingress-gateway-create.yaml
----

[#label-control-service]
== 4.8 Label the control service

In order to enable ingress waypoint routing, label the control service.
The traffic entering the Ingress Gateway will now be forwarded to the Waypoint proxy for L7 policy enforcement.

[source,bash,role=execute]
----
oc apply -f 04_4-label-ingress-use-waypoint.yaml
----

[#create-waypoint-routing]
== 4.9 Create an Ingress Waypoint policy

In this setup (External traffic -> Ingress Gateway -> Waypoint Proxy -> control service), it is recommended to

- apply minimal routing logic at the Ingress Gateway and
- apply all the other logic at the waypoint

Deploy a routing policy that is enforced at the waypoint proxy:

[source,bash,role=execute]
----
oc apply -f 05_1-waypoint-routing.yaml
----

[#expose-ingress-gateway]
== 4.10 Expose the Ingress Gateway

Expose the Ingress Gateway with an OpenShift Route:

[source,bash,role=execute]
----
oc apply -f 05-ingress-gateway-route.yaml
----

You can now access the Travel Control Dashboard through the Service Mesh Ingress Gateway:

[source,bash,role=execute]
----
echo "https://$(oc get routes -n travel-control travel-gateway -o jsonpath='{.spec.host}')"
----

NOTE: **Please keep the browser window open so that you continuously send requests to the backend.**

[#observe-application]
== 4.11 Observe the Travel Demo application

Go to Kiali or use the Service Mesh Console plugin to observe the traffic of the Travel Demo application. Navigate to **Service Mesh -> Traffic Graph**, select the 3 travel demo namespaces and have a look at the `Versioned app graph`

image:kiali-traffic-graph.png[kiali-traffic-graph.png]

In the OpenShift Console, select the travel-agency project and navigate to **Workloads -> Deployments**. Select .i.e the cars-v1 deployment and click on the `Service Mesh` tab:

image:ocp-deployment-ossm-tab.png[ocp-deployment-ossm-tab.png]

In the OpenShift Console, go to Observe -> Metrics and run the query: `istio_tcp_connections_opened_total` to verify that ztunnel uses mTLS:

image:ocp-ossm-metrics.png[ocp-ossm-metrics.png]

[#enable-tracing]
== 4.12 Enable Tracing for the Ingress Gateway and Waypoint Proxy

[source,yaml]
----
apiVersion: telemetry.istio.io/v1
kind: Telemetry
metadata:
  name: telemetry-gateway
  namespace: travel-control
spec:
  targetRefs:
  - kind: Gateway
    name: travel-gateway
    group: gateway.networking.k8s.io
  tracing:
  - providers:
    - name: "otel"
    randomSamplingPercentage: 50
---
apiVersion: telemetry.istio.io/v1
kind: Telemetry
metadata:
  name: telemetry-waypoint
  namespace: travel-control
spec:
  targetRefs:
  - kind: Gateway
    name: travel-control-waypoint
    group: gateway.networking.k8s.io
  tracing:
  - providers:
    - name: "otel"
    randomSamplingPercentage: 50    
----

[source,bash,role=execute]
----
oc apply -f 07-enable-tracing.yaml
----